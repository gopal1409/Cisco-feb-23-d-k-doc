#this network policy is implemented using calico cni plugin
  #check the nodes is any of the nodes is showing not ready to trouble shoot
  a. first check kubelet is running or not
    135  systemctl status kubelet

  b. check containerd is running of not 
  136  systemctl status containerd

  c. check the cni pod is running or not 
   132  kubectl get nodes
  133  kubectl get pod -A
  ###as network policy will be applied in namespace 
  #we will create a namespace and create two pod inside the namespace and check they are communication with each other or not
   139  kubectl create ns ecom
  140  kubectl -n ecom run frontend --image=nginx
  141  kubectl -n ecom run backend --image=nginx
  142  kubectl -n ecom get pod
###lets expose or create service for your pod 
   146  kubectl -n ecom expose pod frontend --port 80
  147  kubectl -n ecom expose pod backend --port 80

  149  kubectl -n ecom get pod,svc
  #lets check that frontend can communicate with backend or not 
  152  kubectl -n ecom exec frontend -- curl backend
  153  kubectl -n ecom exec backend -- curl frontend
###both the way communication is happening
#to disable the communication betwen this pod isnide the namespace we need to create an deny rule
 155  vi default-deny.yml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny
  namespace: ecom 
spec:
  podSelector: {} #from here we start creating exception
    
  policyTypes:
  - Ingress
  - Egress
  
  156  kubectl apply -f default-deny.yml
  157  kubectl -n ecom get networkpolicy
#if you describe the policy you will see everything is disabled ingress and egress routing
  158  kubectl -n ecom describe networkpolicy default-deny
#this time curl request will not work
  159  kubectl -n ecom exec backend -- curl frontend
  160  kubectl -n ecom exec frontend -- curl backend
##lets create the exception where frontend can intiate connection to backend
 165  vi frontend-policy.yml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: frontend-policy
  namespace: ecom 
spec:
  podSelector: #frontend want to intiate connection to the backend and mysql so we will create the policy for frontend
    matchLabels:
      run: frontend
  #in pod selector we will select the frontend pod but how to select the frontend pod we will use the label
  policyTypes:
  - Ingress
  - Egress
  egress:
    - to:
      - podSelector:
          matchLabels:
            run: backend
  166  kubectl apply -f frontend-policy.yml

  168  kubectl -n ecom get networkpolicy
#describe command will show the policy egree routing from frontend to backend
  169  kubectl -n ecom describe networkpolicy frontend-policy
#now also it will not work
  170  kubectl -n ecom exec frontend -- curl backend
#we need to create another policy where backend should accept the connection from frontend
  172  vi backend-policy.yml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-policy
  namespace: ecom 
spec:
  podSelector: #frontend want to intiate connection to the backend and mysql so we will create the policy for frontend
    matchLabels:
      run: backend
  #in pod selector we will select the frontend pod but how to select the frontend pod we will use the label
  policyTypes:
  - Ingress
  - Egress
  ingress:
    - from:
      - podSelector:
          matchLabels:
            run: frontend
  173  kubectl apply -f backend-policy.yml
 
  175  kubectl -n ecom get networkpolicy
  176  kubectl -n ecom describe networkpolicy backend-policy
##now if i try to send traffic from frontend to backend - backend should accept the traffic
#if i try to send the traffic from frontend to backend it will not work
 178  kubectl -n ecom exec frontend -- curl backend
  179  kubectl -n ecom get pod -o wide
##copy the ip address of the backend replace my if with your ip
  180  kubectl -n ecom exec frontend -- curl 10.10.203.20
#using the pod ip address it is working

#lets open port 53 dns port 
188  vi deny2.yml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny
  namespace: ecom
spec:
  podSelector: {} #from here we start creating exception

  policyTypes:
  - Ingress
  - Egress
  egress:
  - to:
    ports:
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 53
#you can use the replace command to replace an exiting object in k8s
  189  kubectl replace -f deny2.yml
##dns resultion will work
  191  kubectl -n ecom exec frontend -- curl backend

